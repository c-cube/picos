<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Computation (picos.Picos.Computation)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">picos</a> &#x00BB; <a href="../index.html">Picos</a> &#x00BB; Computation</nav><header class="odoc-preamble"><h1>Module <code><span>Picos.Computation</span></code></h1><p>A cancelable computation</p><p>A computation simply holds the status, i.e.</p><ul><li>running,</li><li>returned, or</li><li>canceled,</li></ul><p>of some sort of computation.</p><p>As a hopefully helpful analogy, a computation is basically like a cancelable promise and a basic non-cancelable promise can be implemented trivially on top of a computation.</p><p>To define a computation, one first <a href="#val-create"><code>create</code></a>s it and then arranges for the computation to be completed by <a href="#val-return"><code>return</code></a>ing a value through it or by <a href="#val-cancel"><code>cancel</code></a>ing it with an exception at some point in the future. There are no restrictions on what it means for a computation to be running. The cancelation status of a computation can be <a href="#val-check"><code>check</code></a>ed explicitly. Outside observers can <a href="#val-try_attach">attach</a> <a href="../Trigger/index.html">triggers</a> to a computation to get a signal when the computation is completed or <a href="#val-await"><code>await</code></a> the computation. Outside observers may also be selectively given the ability to <a href="#val-cancel"><code>cancel</code></a> a computation.</p><p>Here is an example:</p><pre class="language-ocaml"><code>let computation =
  Computation.create ()
in
let computer =
  Domain.spawn @@ fun () -&gt;
    let rec fib i =
      Computation.check computation;
      if i &lt;= 1 then
        i
      else
        fib (i - 1) + fib (i - 2)
    in
    Computation.capture computation
      fib 10
in
let finally () =
  Domain.join computer
in
Fun.protect ~finally @@ fun () -&gt;

let canceler =
  Domain.spawn @@ fun () -&gt;
    Unix.sleepf 0.1;
    Computation.cancel computation
    @@ Exn_bt.get_callstack 2 Exit
in
let finally () =
  Domain.join canceler
in
Fun.protect ~finally @@ fun () -&gt;

Computation.await computation</code></pre><p>In this framework, a fiber is always associated with <a href="../Fiber/index.html#val-computation">at least a single computation</a>. However, <a href="../Fiber/index.html#val-spawn">it is possible for multiple fibers to share a single computation</a> and it is also possible for a single fiber to perform multiple computations.</p><p>Computations are not hierarchical. In other words, computations do not directly implement structured concurrency. However, it is possible to <a href="#val-canceler">propagate cancelation</a> to implement structured concurrency on top of computations.</p><p>Operations on computations are either wait-free or lock-free and designed to avoid starvation and complete in amortized constant time. The properties of operations to complete a computation depend on the properties of actions <a href="../Trigger/index.html#val-on_signal">attached</a> to the triggers.</p></header><nav class="odoc-toc"><ul><li><a href="#interface-for-creating">Interface for creating</a></li><li><a href="#interface-for-canceling">Interface for canceling</a></li><li><a href="#interface-for-polling">Interface for polling</a></li><li><a href="#interface-for-awaiting">Interface for awaiting</a></li><li><a href="#interface-for-propagating-cancelation">Interface for propagating cancelation</a></li><li><a href="#interface-for-schedulers">Interface for schedulers</a></li><li><a href="#design-rationale">Design rationale</a></li></ul></nav><div class="odoc-content"><h3 id="interface-for-creating"><a href="#interface-for-creating" class="anchor"></a>Interface for creating</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>(!'a, -'allowed) t</span></span></code></div><div class="spec-doc"><p>Represents a cancelable computation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span>[ `Await <span>| `Cancel</span> <span>| `Return</span> ]</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create ()</code> creates a new computation in the running state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finished"><a href="#val-finished" class="anchor"></a><code><span><span class="keyword">val</span> finished : <span><span>(unit, <span>[ `Await <span>| `Cancel</span> <span>| `Return</span> ]</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>finished</code> is a constant finished computation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Return ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>return computation value</code> attempts to complete the computation with the specified <code>value</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-finish"><a href="#val-finish" class="anchor"></a><code><span><span class="keyword">val</span> finish : <span><span><span>(unit, <span>[&gt; `Return ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>finish computation</code> is equivalent to <code>return computation ()</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-capture"><a href="#val-capture" class="anchor"></a><code><span><span class="keyword">val</span> capture : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Cancel <span>| `Return</span> ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>capture computation fn x</code> calls <code>fn x</code> and tries to complete the computation with the value returned or the exception raised by the call.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel_after"><a href="#val-cancel_after" class="anchor"></a><code><span><span class="keyword">val</span> cancel_after : 
  <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Await <span>| `Cancel</span> ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>seconds:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Exn_bt/index.html#type-t">Exn_bt.t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>cancel_after ~seconds computation exn_bt</code> arranges to <a href="#val-cancel"><code>cancel</code></a> the computation after the specified time with the specified exception and backtrace. Completion of the computation before the specified time effectively cancels the timeout.</p><p>The implementation will first try to perform <a href="#extension-Cancel_after"><code>Cancel_after</code></a> and falls back to a default implementation using <code>Thread</code>s if possible.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if <code>seconds</code> is negative.</p></li></ul></div></div><h3 id="interface-for-canceling"><a href="#interface-for-canceling" class="anchor"></a>Interface for canceling</h3><div class="odoc-spec"><div class="spec type anchored" id="type-as_cancelable"><a href="#type-as_cancelable" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a as_cancelable</span></span><span> = <span><span>(<span class="type-var">'a</span>, <span>[ `Await <span>| `Cancel</span> ]</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym for a computation that only allows cancelation aside from await.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-packed"><a href="#type-packed" class="anchor"></a><code><span><span class="keyword">type</span> <span>-'allowed packed</span></span><span> = </span></code><ol><li id="type-packed.Packed" class="def variant constructor anchored"><a href="#type-packed.Packed" class="anchor"></a><code><span>| </span><span><span class="constructor">Packed</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'allowed</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'allowed</span> <a href="#type-packed">packed</a></span></span></code></li></ol></div><div class="spec-doc"><p>An existential wrapper for computations.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-packed_as_cancelable"><a href="#type-packed_as_cancelable" class="anchor"></a><code><span><span class="keyword">type</span> packed_as_cancelable</span><span> = <span><span>[ `Await <span>| `Cancel</span> ]</span> <a href="#type-packed">packed</a></span></span></code></div><div class="spec-doc"><p>Synonym for a packed computation that only allows cancelation aside from await.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cancel"><a href="#val-cancel" class="anchor"></a><code><span><span class="keyword">val</span> cancel : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Cancel ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Exn_bt/index.html#type-t">Exn_bt.t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>cancel computation exn_bt</code> attempts to mark the computation as canceled with the specified exception and backtrace.</p></div></div><h3 id="interface-for-polling"><a href="#interface-for-polling" class="anchor"></a>Interface for polling</h3><div class="odoc-spec"><div class="spec value anchored" id="val-is_running"><a href="#val-is_running" class="anchor"></a><code><span><span class="keyword">val</span> is_running : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_running computation</code> determines whether the computation is in the running state meaning that it has not yet been completed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-canceled"><a href="#val-canceled" class="anchor"></a><code><span><span class="keyword">val</span> canceled : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Exn_bt/index.html#type-t">Exn_bt.t</a> option</span></span></code></div><div class="spec-doc"><p><code>canceled computation</code> returns the exception that the computation has been canceled with or returns <code>None</code> in case the computation has not been canceled.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-check"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">_</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check computation</code> is equivalent to <code>Option.iter Exn_bt.raise (canceled computation)</code>.</p></div></div><h3 id="interface-for-awaiting"><a href="#interface-for-awaiting" class="anchor"></a>Interface for awaiting</h3><div class="odoc-spec"><div class="spec value anchored" id="val-try_attach"><a href="#val-try_attach" class="anchor"></a><code><span><span class="keyword">val</span> try_attach : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Await ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>[&gt; `Signal ]</span> <a href="../Trigger/index.html#type-t">Trigger.t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>try_attach computation trigger</code> tries to attach the trigger to be signaled on completion of the computation and returns <code>true</code> on success. Otherwise returns <code>false</code>, which means that the computation has already been completed.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-detach"><a href="#val-detach" class="anchor"></a><code><span><span class="keyword">val</span> detach : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Await ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>[&gt; `Signal ]</span> <a href="../Trigger/index.html#type-t">Trigger.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>detach computation trigger</code> <a href="../Trigger/index.html#val-signal">signals</a> the trigger and detaches it from the computation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span>(<span class="type-var">'a</span>, <span>[&gt; `Await ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await computation</code> waits for the computation to complete and either returns the value of the completed computation or raises the exception the computation was canceled with.</p></div></div><h3 id="interface-for-propagating-cancelation"><a href="#interface-for-propagating-cancelation" class="anchor"></a>Interface for propagating cancelation</h3><div class="odoc-spec"><div class="spec value anchored" id="val-canceler"><a href="#val-canceler" class="anchor"></a><code><span><span class="keyword">val</span> canceler : 
  <span>from:<span><span>(<span class="type-var">'a</span>, <span>[&gt; `Await ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>into:<span><span>(<span class="type-var">'b</span>, <span>[&gt; `Cancel ]</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ `Signal ]</span> <a href="../Trigger/index.html#type-t">Trigger.t</a></span></span></code></div><div class="spec-doc"><p><code>canceler ~from ~into</code> creates a trigger that propagates cancelation <code>from</code> one computation <code>into</code> another on <a href="Trigger.signal">signal</a>.</p><p>The returned trigger is usually attached to the computation <code>from</code> which cancelation is to be propagated and the trigger should usually also be detached after it is no longer needed.</p></div></div><h3 id="interface-for-schedulers"><a href="#interface-for-schedulers" class="anchor"></a>Interface for schedulers</h3><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Cancel_after"><a href="#extension-decl-Cancel_after" class="anchor"></a><code><span><span class="keyword">type</span> <span class="xref-unresolved">Stdlib</span>.Effect.t += </span></code><ol><li id="extension-Cancel_after" class="def extension anchored"><a href="#extension-Cancel_after" class="anchor"></a><code><span>| </span><span><span class="extension">Cancel_after</span> : </span><span>{</span></code><ol><li id="module-Computation.seconds" class="def record field anchored"><a href="#module-Computation.seconds" class="anchor"></a><code><span>seconds : float;</span></code></li><li id="module-Computation.exn_bt" class="def record field anchored"><a href="#module-Computation.exn_bt" class="anchor"></a><code><span>exn_bt : <a href="../Exn_bt/index.html#type-t">Exn_bt.t</a>;</span></code></li><li id="module-Computation.computation" class="def record field anchored"><a href="#module-Computation.computation" class="anchor"></a><code><span>computation : <span><span class="type-var">'a</span> <a href="#type-as_cancelable">as_cancelable</a></span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span>unit <span class="xref-unresolved">Stdlib</span>.Effect.t</span></span></code></li></ol></div><div class="spec-doc"><p>Schedulers may handle the <a href="#extension-Cancel_after"><code>Cancel_after</code></a> effect to customize the behavior of <a href="#val-cancel_after"><code>cancel_after</code></a>.</p></div></div><h3 id="design-rationale"><a href="#design-rationale" class="anchor"></a>Design rationale</h3><p>The computation concept can be seen as a generalization of both a cancelation context or token and of a promise. Unlike a typical promise mechanism, a computation can be canceled. Unlike a typical cancelation mechanism, a computation can and should also be completed in case it is not canceled. This promotes proper scoping of computations and resource cleanup at completion, which is how the design evolved from a more traditional cancelation context design.</p><p>In this framework, <a href="../Fiber/index.html#val-computation">every fiber has an associated computation</a>. Being able to return a value through the computation means that no separate promise is necessarily required to hold the result of a fiber. On the other hand, in this framework, <a href="../Fiber/index.html#val-spawn">multiple fibers may share a single computation</a>. This allows multiple fibers to be canceled efficiently through a single atomic update. In other words, the design allows various higher level patterns to be implemented efficiently.</p><p>Instead of directly implementing a hierarchy of computations, the design allows <a href="#val-try_attach">attach</a>ing triggers to computations and <a href="#val-canceler">a special trigger constructor</a> is provided for propagating cancelation. This helps to keep the implementation lean, i.e. not substantially heavier than a typical promise implementation.</p><p>Finally, just like with <a href="../Trigger/index.html#extension-Await"><code>Trigger.Await</code></a>, a key idea is that the handler of <a href="#extension-Cancel_after"><code>Computation.Cancel_after</code></a> does not need to run arbitrary user defined code. The action of any trigger attached to a computation either comes from some scheduler calling <a href="../Trigger/index.html#val-on_signal"><code>Trigger.on_signal</code></a> or from <a href="#val-canceler"><code>Computation.canceler</code></a>.</p></div></body></html>