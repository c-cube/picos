<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Picos (picos.Picos)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">picos</a> &#x00BB; Picos</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#picos-â€”-interoperable-effects-based-concurrency">Picos â€” Interoperable effects based concurrency</a><ul><li><a href="#introduction">Introduction</a><ul><li><a href="#understanding-cancelation">Understanding cancelation</a><ul><li><a href="#cancelation-in-picos">Cancelation in Picos</a></li></ul></li><li><a href="#the-architecture-of-picos">The architecture of Picos</a><ul><li><a href="#picos-compatible">Picos compatible</a></li><li><a href="#implemented-in-picos">Implemented in Picos</a></li></ul></li><li><a href="#design-goals-and-principles">Design goals and principles</a><ul><li><a href="#constraints-liberate,-liberties-constrain">Constraints Liberate, Liberties Constrain</a></li></ul></li></ul></li><li><a href="#modules-reference">Modules reference</a><ul><li><a href="#auxiliary-modules">Auxiliary modules</a></li><li><a href="#core-modules">Core modules</a></li></ul></li><li><a href="#advanced-topics">Advanced topics</a><ul><li><a href="#default-behaviors">Default behaviors</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h2 id="picos-â€”-interoperable-effects-based-concurrency"><a href="#picos-â€”-interoperable-effects-based-concurrency" class="anchor"></a>Picos â€” Interoperable effects based concurrency</h2><h3 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h3><p>Picos, or <a href="https://en.wikipedia.org/wiki/Metric_prefix">pico</a>-scheduler framework, is a framework for building <a href="https://en.wikipedia.org/wiki/Interoperability">interoperable</a> elements of <a href="https://v2.ocaml.org/manual/effects.html">effects based</a> <a href="https://en.wikipedia.org/wiki/Cooperative_multitasking">cooperative</a> <a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrent programming models</a>. Such models include elements such as</p><ul><li><a href="https://en.wikipedia.org/wiki/Scheduling_(computing)">schedulers</a> that multiplex large numbers of <a href="https://en.wikipedia.org/wiki/Green_thread">user level fibers</a> to run on a small number of system level threads,</li><li>mechanisms for managing fibers and for <a href="https://en.wikipedia.org/wiki/Structured_concurrency">structuring concurrency</a>,</li><li>communication and synchronization primitives, such as <a href="https://en.wikipedia.org/wiki/Monitor_(synchronization)">mutexes and condition variables</a>, message queues, <a href="https://en.wikipedia.org/wiki/Software_transactional_memory">STMs</a>, and more, and</li><li>integration with low level <a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">asynchronous IO</a> systems.</li></ul><p>Picos is not intended to be an application level concurrent programming library or framework. If you are looking for a library or framework for programming concurrent applications, then Picos is probably not what you are looking for.</p><p>If you are the author of an application level concurrent programming library or framework, then Picos should not fundamentally be competing with your work. However, Picos and libraries built on top of Picos probably do have overlap with your work and making your work Picos compatible may offer benefits:</p><ul><li>You may find it useful that Picos provides parallelism safe building blocks for cancelation, which is a particularly tricky problem to get right.</li><li>You may find it useful that you don't have to reinvent many of the basic communication and synchronization abstractions such as mutexes and condition variables, promises, concurrent bounded queues, channels, and what not.</li><li>You may benefit from further non-trivial libraries, such as IO libraries, that you don't have to reimplement.</li><li>Potential users of your work may be reassured and benefit from the ability to mix-and-match your work with other Picos compatible libraries and frameworks.</li></ul><p>Of course, interoperability does have some costs. It takes time to understand Picos and it takes time to implement Picos compatibility. Implementing your programming model elements in terms of Picos primitives may not give ideal results. To address concerns such as those, a conscious effort has been made to keep Picos as minimal and unopinionated as possible.</p><h4 id="understanding-cancelation"><a href="#understanding-cancelation" class="anchor"></a>Understanding cancelation</h4><p>A central idea of Picos is to provide a collection of building blocks for parallelism safe cancelation. Consider the following characteristic example:</p><pre class="language-ocaml"><code>Mutex.protect mutex begin fun () -&gt;
  while true do
    Condition.wait condition mutex
  done
end</code></pre><p>Assume that the fiber executing the above computation might be canceled, at any point, by another fiber running in parallel. How could that be done both effectively and safely?</p><ul><li>To be effective, cancelation should take effect as soon as possible. In this case, cancelation should take effect even during the <code>Mutex.lock</code> inside <code>Mutex.protect</code> and the <code>Condition.wait</code> operations when the fiber might be in a suspended state awaiting for a signal to continue.</li><li>To be safe, cancelation should not leave the program in an invalid state or cause the program to leak memory. In this case, the ownership of the mutex must be transferred to the next fiber or be left unlocked and no references to unused objects must be left in the mutex or the condition variable.</li></ul><p>Picos allows <code>Mutex</code> and <code>Condition</code> to be implemented such that cancelation may safely take effect at or during calls to <code>Mutex.lock</code> and <code>Condition.wait</code>.</p><h5 id="cancelation-in-picos"><a href="#cancelation-in-picos" class="anchor"></a>Cancelation in Picos</h5><p>The <a href="Fiber/index.html"><code>Fiber</code></a> concept in Picos corresponds to an independent thread of execution. A fiber may explicitly <a href="Fiber/index.html#val-forbid" title="Fiber.forbid">forbid</a> or <a href="Fiber/index.html#val-permit" title="Fiber.permit">permit</a> the scheduler from propagating cancelation to it. This is important for the implementation of some key concurrent abstractions such as condition variables, where it is necessary to forbid cancelation when the associated mutex is re-acquired.</p><p>Each fiber has an associated <a href="Computation/index.html"><code>Computation</code></a>. A computation is something that needs to be completed either by <a href="Computation/index.html#val-return" title="Computation.return">returning</a> a value through it or by <a href="Computation/index.html#val-cancel" title="Computation.cancel">canceling</a> it with an exception. To cancel a fiber one cancels the <a href="Fiber/index.html#val-computation" title="Fiber.computation">computation</a> associated with the fiber.</p><p>Before a computation has been completed, it is also possible to <a href="Computation/index.html#val-try_attach" title="Computation.try_attach">attach</a> a <a href="Trigger/index.html"><code>Trigger</code></a> to the computation and also to later <a href="Computation/index.html#val-detach" title="Computation.detach">detach</a> the trigger from the computation. A trigger attached to a computation is <a href="Trigger/index.html#val-signal" title="Trigger.signal">signaled</a> as the computation is completed.</p><p>The <a href="Trigger/index.html"><code>Trigger</code></a> concept in Picos is what allows a fiber to be suspended and later resumed. A fiber can create a trigger, add it to any shared data structure(s), and <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> for the trigger to be signaled. The await operation, which is <a href="Trigger/index.html#extension-Await" title="Trigger.Await">implemented by the scheduler</a>, also, in case the fiber permits cancelation, attaches the trigger to the computation of the fiber when it suspends the fiber. This is what allows a fiber to be resumed via cancelation of the computation.</p><p>The return value of <a href="Trigger/index.html#val-await" title="Trigger.await">await</a> tells whether the fiber was resumed normally or due to being canceled and the caller then needs to properly handle either case. After being canceled, depending on the concurrent abstraction being implemented, the caller might need to e.g. remove references to the trigger from the shared data structures, cancel asynchronous IO operations, or transfer ownership of a mutex to the next fiber in the queue of the mutex.</p><h4 id="the-architecture-of-picos"><a href="#the-architecture-of-picos" class="anchor"></a>The architecture of Picos</h4><p>The core concepts of Picos are</p><ul><li><a href="Trigger/index.html"><code>Trigger</code></a> â€” ability to await for a signal,</li><li><a href="Computation/index.html"><code>Computation</code></a> â€” a cancelable computation, and</li><li><a href="Fiber/index.html"><code>Fiber</code></a> â€” an independent thread of execution,</li></ul><p>that are implemented in terms of the effects</p><ul><li><a href="Trigger/index.html#extension-Await"><code>Trigger.Await</code></a> â€” to suspend and resume a fiber,</li><li><a href="Computation/index.html#extension-Cancel_after"><code>Computation.Cancel_after</code></a> â€” to cancel a computation after given period of time,</li><li><a href="Fiber/index.html#extension-Current"><code>Fiber.Current</code></a> â€” to obtain the unique handle of the current fiber,</li><li><a href="Fiber/index.html#extension-Yield"><code>Fiber.Yield</code></a> â€” to cooperatively request rescheduling the current fiber, and</li><li><a href="Fiber/index.html#extension-Spawn"><code>Fiber.Spawn</code></a> â€” to start new fibers,</li></ul><p>that can be used to implement many kinds of higher level concurrent programming facilities.</p><h5 id="picos-compatible"><a href="#picos-compatible" class="anchor"></a>Picos compatible</h5><p>The idea is that in OCaml 5, effects based schedulers provide their own handlers for the Picos effects. By handling the Picos effects a scheduler becomes Picos compatible and allows any libraries built on top of Picos to be used with the scheduler.</p><h5 id="implemented-in-picos"><a href="#implemented-in-picos" class="anchor"></a>Implemented in Picos</h5><p>A scheduler is just one element of a concurrent programming model. Separately from making a scheduler Picos compatible, one may choose to implement other elements of the programming model, e.g. a particular approach to structuring concurrency or a particular collection of communication and synchronization primitives, in terms of the Picos primitives. Such elements can then be used on any Picos compatible scheduler.</p><h4 id="design-goals-and-principles"><a href="#design-goals-and-principles" class="anchor"></a>Design goals and principles</h4><ul><li><b>Simple</b>: Picos should be kept as simple as possible.</li><li><b>Minimal</b>: Picos should be kept minimal. The dependency footprint should be as small as possible. Convenience features should be built on top of the framework.</li><li><b>Safe</b>: Picos should be designed with safety in mind. The implementation must be data race free. The framework should promote and always allow proper resource management.</li><li><b>Unopinionated</b>: Picos should not make strong design choices that are controversial.</li><li><b>Flexible</b>: Picos should allow higher level libraries as much freedom as possible to make their own design choices.</li></ul><p>The documentation of the concepts includes design rationale for some of the specific ideas behind their detailed design.</p><h5 id="constraints-liberate,-liberties-constrain"><a href="#constraints-liberate,-liberties-constrain" class="anchor"></a>Constraints Liberate, Liberties Constrain</h5><p>Picos aims to be unopinionated and flexible enough to allow higher level libraries to provide many different kinds of concurrent programming models. While it is impossible to give a complete list of what Picos does not dictate, it is perhaps illuminating to explicitly mention some of those:</p><ul><li>Picos does not implement <a href="https://en.wikipedia.org/wiki/Capability-based_security">capability-based security</a>. Higher level libraries with or without capabilities may be built on top of Picos.</li><li>Picos never cancels computations implicitly. Higher level libraries may decide when cancelation should be allowed to take effect.</li><li>Picos does not dictate which fiber should be scheduled next after a Picos effect. Different schedulers may freely use desired data structures (queues, work-stealing deques, stacks, priority queues, ...) and, after handling any Picos effect, freely decide which fiber to run next.</li><li>Picos does not dictate how fibers should be managed. It is possible to implement both unstructured and structured concurrent programming models on top of Picos.</li><li>Picos does not dictate which mechanisms applications should use for communication and synchronization. It is possible to build many different kinds of communication and synchronization mechanisms on top of Picos including mutexes and condition variables, STMs, asynchronous and synchronous message passing, <a href="https://en.wikipedia.org/wiki/Actor_model">actors</a>, and more.</li><li>Picos does not dictate that there should be a connection between the scheduler and other elements of the concurrent programming model. It is possible to provide those separately and mix-and-match.</li><li>Picos does not dictate which library to use for IO. It is possible to build direct-style asynchronous IO libraries on top of Picos that can then be used with any Picos compatible schedulers or concurrent programming models.</li></ul><p>Let's build an incredible ecosystem of interoperable concurrent programming libraries and frameworks!</p><h3 id="modules-reference"><a href="#modules-reference" class="anchor"></a>Modules reference</h3><pre class="language-ocaml"><code>open Picos</code></pre><h4 id="auxiliary-modules"><a href="#auxiliary-modules" class="anchor"></a>Auxiliary modules</h4><div class="odoc-spec"><div class="spec module anchored" id="module-Exn_bt"><a href="#module-Exn_bt" class="anchor"></a><code><span><span class="keyword">module</span> Exn_bt</span><span> = <a href="../Picos_exn_bt/index.html">Picos_exn_bt</a></span></code></div><div class="spec-doc"><p>Exceptions with backtraces.</p></div></div><h4 id="core-modules"><a href="#core-modules" class="anchor"></a>Core modules</h4><p>Please note that the example code snippets in this documentation may e.g. use the <code>Domain</code> and <code>Unix</code> modules in order to be able to describe Picos concepts in isolation in the absence of a Picos compatible scheduler.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Trigger"><a href="#module-Trigger" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Trigger/index.html">Trigger</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Ability to await for a signal</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Computation"><a href="#module-Computation" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Computation/index.html">Computation</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A cancelable computation</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fiber"><a href="#module-Fiber" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fiber/index.html">Fiber</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An independent thread of execution</p></div></div><h3 id="advanced-topics"><a href="#advanced-topics" class="anchor"></a>Advanced topics</h3><h4 id="default-behaviors"><a href="#default-behaviors" class="anchor"></a>Default behaviors</h4><p>All of the effects based operations</p><ul><li><a href="Trigger/index.html#val-await"><code>Trigger.await</code></a>,</li><li><a href="Computation/index.html#val-cancel_after"><code>Computation.cancel_after</code></a>,</li><li><a href="Fiber/index.html#val-current"><code>Fiber.current</code></a>,</li><li><a href="Fiber/index.html#val-yield"><code>Fiber.yield</code></a>, and</li><li><a href="Fiber/index.html#val-spawn"><code>Fiber.spawn</code></a></li></ul><p>have default behaviors on OCaml 4.</p><p>The underlying idea behind the defaults is to make it so that a fiber corresponds to a <code>Thread</code>.</p><p>Briefly:</p><ul><li>The default <a href="Fiber/index.html#val-spawn" title="Fiber.spawn"><code>spawn</code></a> creates a thread for each fiber.</li><li>The default <a href="Fiber/index.html#val-current" title="Fiber.current"><code>current</code></a> uses <a href="../Picos_tls/index.html"><code>Picos_tls</code></a> to store the current fiber.</li><li>The default <a href="Fiber/index.html#val-yield" title="Fiber.yield"><code>yield</code></a> just calls <code>Thread.yield</code>.</li><li>The default <a href="Trigger/index.html#val-await" title="Trigger.await"><code>await</code></a> uses <a href="../Picos_tls/index.html"><code>Picos_tls</code></a> to store a <code>Mutex</code> and <code>Condition</code> to suspend the thread.</li><li>The default <a href="Computation/index.html#val-cancel_after" title="Computation.cancel_after"><code>cancel_after</code></a> uses <a href="../Picos_domain/DLS/index.html"><code>Picos_domain.DLS</code></a> to store a priority queue of timeouts and a per-domain background timeout thread that runs a <code>Unix.select</code> loop to cancel computations.</li></ul><p>The default behaviors initialize their resources, per-thread, and per-domain state and the background timeout thread, only when actually used. If the default <a href="Computation/index.html#val-cancel_after" title="Computation.cancel_after"><code>cancel_after</code></a> is not used, no background timeout thread will be created and no per-domain state will be used. If none of the defaults are used, no per-thread state will be used.</p></div></body></html>
