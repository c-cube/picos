<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Trigger (picos.Picos.Trigger)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> ‚Äì <a href="../../index.html">picos</a> &#x00BB; <a href="../index.html">Picos</a> &#x00BB; Trigger</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="üîé Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Picos.Trigger</span></code></h1><p>Ability to await for a signal</p><p>To suspend and later resume the current thread of execution, one can <a href="#val-create"><code>create</code></a> a trigger, arrange <a href="#val-signal"><code>signal</code></a> to be called on it, and <a href="#val-await"><code>await</code></a> for the call.</p><p>Here is a simple example:</p><pre class="language-ocaml"><code>let trigger = Trigger.create () in

let signaler =
  Domain.spawn @@ fun () -&gt;
    Trigger.signal trigger
in
let finally () =
  Domain.join signaler
in
Fun.protect ~finally @@ fun () -&gt;

match Trigger.await trigger with
| None -&gt;
  (* We were resumed normally. *)
  ()
| Some exn_bt -&gt;
  (* We were canceled.

     Typically we'd cleanup here. *)
  Exn_bt.raise exn_bt</code></pre><p>All operations on triggers are wait-free, with the obvious exception of <a href="#val-await"><code>await</code></a>. The <a href="#val-signal"><code>signal</code></a> operation inherits the properties of the action attached with <a href="#val-on_signal"><code>on_signal</code></a> to the trigger.</p></header><nav class="odoc-toc"><ul><li><a href="#interface-for-suspending">Interface for suspending</a></li><li><a href="#interface-for-resuming">Interface for resuming</a></li><li><a href="#interface-for-schedulers">Interface for schedulers</a></li><li><a href="#design-rationale">Design rationale</a></li></ul></nav><div class="odoc-content"><h3 id="interface-for-suspending"><a href="#interface-for-suspending" class="anchor"></a>Interface for suspending</h3><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>-'allowed t</span></span></code></div><div class="spec-doc"><p>Represents a trigger.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-create"><a href="#val-create" class="anchor"></a><code><span><span class="keyword">val</span> create : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Await <span>| `Signal</span> ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>create ()</code> allocates a new trigger in the initial state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_initial"><a href="#val-is_initial" class="anchor"></a><code><span><span class="keyword">val</span> is_initial : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_initial trigger</code> determines whether the trigger is in the initial state.</p><p>‚ö†Ô∏è Consider using <a href="#val-is_signaled"><code>is_signaled</code></a> instead of <code>is_initial</code> as in some contexts a trigger might reasonably be either in the initial or the awaiting state depending on the order in which things are being done.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_signaled"><a href="#val-is_signaled" class="anchor"></a><code><span><span class="keyword">val</span> is_signaled : <span><span><span class="type-var">_</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_signaled trigger</code> determines whether the trigger is in the signaled state.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-await"><a href="#val-await" class="anchor"></a><code><span><span class="keyword">val</span> await : <span><span><span>[&gt; `Await ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Exn_bt/index.html#type-t">Exn_bt.t</a> option</span></span></code></div><div class="spec-doc"><p><code>await trigger</code> waits for the trigger to be <a href="#val-signal"><code>signal</code></a>ed.</p><p>The return value is <code>None</code> in case the trigger was signaled before <code>await</code> or the <a href="../Fiber/index.html" title="Fiber">fiber</a> was resumed normally. Otherwise the return value is <code>Some exn_bt</code>, which indicates that the fiber has been canceled and the caller should raise the exception. In either case the caller is responsible for cleaning up. Usually this means making sure that no references to the trigger remain to avoid space leaks.</p><p>‚ö†Ô∏è Only the owner or creator of a trigger may call <code>await</code> and it is considered an error to make multiple concurrent calls to <code>await</code>.</p><p>On OCaml 5, <code>await</code> will first try to perform the <a href="#extension-Await"><code>Await</code></a> effect and falls back to the OCaml 4 default implementation that suspends the underlying system level thread using a per thread <code>Mutex</code> and <code>Condition</code> variable.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the trigger was in the awaiting state, which means that multiple concurrent calls of <code>await</code> are being made.</p></li></ul></div></div><h3 id="interface-for-resuming"><a href="#interface-for-resuming" class="anchor"></a>Interface for resuming</h3><div class="odoc-spec"><div class="spec type anchored" id="type-as_signal"><a href="#type-as_signal" class="anchor"></a><code><span><span class="keyword">type</span> as_signal</span><span> = <span><span>[ `Signal ]</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Synonym for a trigger that only allows the <a href="#val-signal"><code>signal</code></a> operation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-signal"><a href="#val-signal" class="anchor"></a><code><span><span class="keyword">val</span> signal : <span><span><span>[&gt; `Signal ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>After <code>signal trigger</code> returns, the trigger has been put into the signaled state and any attached action has been called.</p><p>Note that under normal circumstances, <code>signal</code> should never raise an exception. If an exception is raised by <code>signal</code>, it means that the handler of <a href="#extension-Await"><code>Await</code></a> has a bug or some catastrophic failure has occurred.</p></div></div><h3 id="interface-for-schedulers"><a href="#interface-for-schedulers" class="anchor"></a>Interface for schedulers</h3><div class="odoc-spec"><div class="spec value anchored" id="val-on_signal"><a href="#val-on_signal" class="anchor"></a><code><span><span class="keyword">val</span> on_signal : 
  <span><span><span>[&gt; `On <span>| `Signal</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'x</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'y</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span>[&gt; `Signal ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'x</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'y</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>on_signal trigger x y resume</code> attempts to attach the <code>resume</code> action to the <code>trigger</code> and transition the trigger to the awaiting state. It must be safe to call <code>resume trigger x y</code> from any context that <a href="#val-signal"><code>signal</code></a> might be called from.</p><p>The return value is <code>true</code> in case the action was attached successfully. Otherwise the return value is <code>false</code>, which means that the trigger was already in the signaled state.</p><p>‚ö†Ô∏è The handler of <a href="#extension-Await"><code>Await</code></a> should call <code>on_signal</code> at most once.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Invalid_argument</code> <p>if the trigger was in the awaiting state, which means that either the owner or creator of the trigger made concurrent calls to <a href="#val-await"><code>await</code></a> or the handler called <code>on_signal</code> more than once.</p></li></ul></div></div><div class="odoc-spec"><div class="spec type extension anchored" id="extension-decl-Await"><a href="#extension-decl-Await" class="anchor"></a><code><span><span class="keyword">type</span> <span class="xref-unresolved">Stdlib</span>.Effect.t += <span class="keyword">private</span> </span></code><ol><li id="extension-Await" class="def variant extension anchored"><a href="#extension-Await" class="anchor"></a><code><span>| </span><span><span class="extension">Await</span> : <span><span>[ `On <span>| `Signal</span> ]</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span> <span><span><a href="../Exn_bt/index.html#type-t">Exn_bt.t</a> option</span> <span class="xref-unresolved">Stdlib</span>.Effect.t</span></span></code></li></ol></div><div class="spec-doc"><p>Schedulers may handle the <a href="#extension-Await"><code>Await</code></a> effect to customize the behavior of <code>await</code>.</p><p>In case the fiber permits propagation of cancelation, the trigger should be attached to the computation of the fiber for the duration of suspending the fiber.</p><p>Whether being resumed due to cancelation or not, the trigger should be signaled before resuming the fiber.</p><p>The scheduler is free to choose which ready fiber to resume next.</p></div></div><h3 id="design-rationale"><a href="#design-rationale" class="anchor"></a>Design rationale</h3><p>A key idea behind this design is that the handler for <a href="#extension-Await"><code>Await</code></a> does not need to run arbitrary user defined code while suspending a fiber: the handler calls <a href="#val-on_signal"><code>on_signal</code></a> by itself. This should make it easier to get both the handler and the user code correct.</p><p>Another key idea is that the <a href="#val-signal"><code>signal</code></a> operation provides no feedback as to the outcome regarding cancelation. Calling <a href="#val-signal"><code>signal</code></a> merely guarantees that the caller of <a href="#val-await"><code>await</code></a> will return. This means that the point at which cancelation must be determined can be as late as possible. A scheduler can check the cancelation status just before calling <code>continue</code> and it is, of course, possible to check the cancelation status earlier. This allows maximal flexibility for the handler of <a href="#extension-Await"><code>Await</code></a>.</p><p>The consequence of this is that the only place to handle cancelation is at the point of <a href="#val-await"><code>await</code></a>. This makes the design simpler and should make it easier for the user to get the handling of cancelation right. A minor detail is that <a href="#val-await"><code>await</code></a> returns an option instead of raising an exception. The reason for this is that matching against an option is slightly faster than setting up an exception handler. Returning an option also clearly communicates the two different cases to handle.</p><p>On the other hand, the trigger mechanism does not have a way to specify a user-defined callback to perform cancelation immediately before the fiber is resumed. Such an immediately called callback could be useful for e.g. canceling an underlying IO request. One justification for not having such a callback is that cancelation is allowed to take place from outside of the scheduler, i.e. from another system level thread, and, in such a case, the callback could not be called immediately. Instead, the scheduler is free to choose how to schedule canceled and continued fibers and, assuming that fibers can be trusted, a scheduler may give priority to canceled fibers.</p><p>This design also separates the allocation of the atomic state for the trigger, or <a href="#val-create"><code>create</code></a>, from <a href="#val-await"><code>await</code></a>, and allows the state to be polled using <a href="#val-is_signaled"><code>is_signaled</code></a> before calling <a href="#val-await"><code>await</code></a>. This is particularly useful when the trigger might need to be inserted to multiple places and be <a href="#val-signal"><code>signal</code></a>ed in parallel before the call of <a href="#val-await"><code>await</code></a>.</p><p>No mechanism is provided to communicate any result with the signal. That can be done outside of the mechanism and is often not needed. This simplifies the design.</p><p>Once <a href="#val-signal"><code>signal</code></a> has been called, a trigger no longer refers to any other object and takes just two words of memory. This e.g. allows lazy removal of triggers.</p><p>To further understand the problem domain, in this design, in a suspend-resume scenario, there are three distinct pieces of state:</p><ol><li>The state of shared data structure(s) used for communication and / or synchronization.</li><li>The state of the trigger.</li><li>The cancelation status of the fiber.</li></ol><p>The trigger and cancelation status are both updated independently and atomically through code in this framework. The key requirement left for the user is to make sure that the state of the shared data structure is updated correctly independently of what <a href="#val-await"><code>await</code></a> returns. So, for example, a mutex implementation must check, after getting <code>Some exn_bt</code>, what the state of the mutex is and how it should be updated.</p></div></body></html>
